{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction EasyTensor is the fastest way to deploy and share your ML models online. To get started install our python package , or upload your model via our GUI on easytensor.com .","title":"Introduction"},{"location":"#introduction","text":"EasyTensor is the fastest way to deploy and share your ML models online. To get started install our python package , or upload your model via our GUI on easytensor.com .","title":"Introduction"},{"location":"PyTorch/","text":"PyTorch PyTorch models are packaged in two parts: The serialized parameters (weights and biases) of the model. The model class, including a prediction method. EasyTensor is able to store and upload the model's parameters (1) automatically, but needs your help in defining the model's architecture and prediction method (2). Once you have your model class and weights ready, simpl run import easytensor easytensor . pytorch . upload_model ( \"My PyTorch Model\" , model , \"model.py\" ) Saving Model Class This model class must include a predict_single method that can take in your native input format and return a human readible output. You can think of the predict_single method as where the preprocess, predict, and postprocess happens. from torch import nn class MyAwesomeModel ( nn . Module ): def __init__ ( self ): super ( MyAwesomeModel , self ) . __init__ () ... def predict_single ( self , input_instance ): return input_instance predict_single The predict_single method will be called once for every query you run against the inference server. It must accept native input (e.g. text, image bytes, number array) and return a JSON serializable object that will be sent back to the user. Here are a few input/output examples: Text classification Liverpool beat Manchest United 4-2 on May 13th --> sports where can i find the best food in town? --> location In the face of overwhelming failure, Tom found success --> quotes Here is a more complex example that starts up a neural network trained to classify news articles. from torch import nn import torch.tensor from torchtext.datasets import AG_NEWS from torchtext.data.utils import get_tokenizer from collections import Counter from torchtext.vocab import Vocab tokenizer = get_tokenizer ( \"basic_english\" ) train_iter = AG_NEWS ( split = \"train\" ) counter = Counter () for ( label , line ) in train_iter : counter . update ( tokenizer ( line )) vocab = Vocab ( counter , min_freq = 1 ) text_pipeline = lambda x : [ vocab [ token ] for token in tokenizer ( x )] label_pipeline = lambda x : int ( x ) - 1 ag_news_label = { 1 : \"World\" , 2 : \"Sports\" , 3 : \"Business\" , 4 : \"Sci/Tec\" } class TextClassificationModel ( nn . Module ): def __init__ ( self , vocab_size = 95812 , embed_dim = 64 , num_class = 4 ): super ( TextClassificationModel , self ) . __init__ () self . embedding = nn . EmbeddingBag ( vocab_size , embed_dim , sparse = True ) self . fc = nn . Linear ( embed_dim , num_class ) self . init_weights () self . tokenizer = text_pipeline def init_weights ( self ): initrange = 0.5 self . embedding . weight . data . uniform_ ( - initrange , initrange ) self . fc . weight . data . uniform_ ( - initrange , initrange ) self . fc . bias . data . zero_ () def forward ( self , tokens , offset ): embedded = self . embedding ( tokens , offset ) return self . fc ( embedded ) def predict_single ( self , input : str ): tokenized = torch . tensor ( text_pipeline ( input )) output = self . forward ( tokenized , torch . tensor ([ 0 ])) prediction = output . argmax ( 1 ) . item () + 1 return ag_news_label [ prediction ]","title":"PyTorch"},{"location":"PyTorch/#pytorch","text":"PyTorch models are packaged in two parts: The serialized parameters (weights and biases) of the model. The model class, including a prediction method. EasyTensor is able to store and upload the model's parameters (1) automatically, but needs your help in defining the model's architecture and prediction method (2). Once you have your model class and weights ready, simpl run import easytensor easytensor . pytorch . upload_model ( \"My PyTorch Model\" , model , \"model.py\" )","title":"PyTorch"},{"location":"PyTorch/#saving-model-class","text":"This model class must include a predict_single method that can take in your native input format and return a human readible output. You can think of the predict_single method as where the preprocess, predict, and postprocess happens. from torch import nn class MyAwesomeModel ( nn . Module ): def __init__ ( self ): super ( MyAwesomeModel , self ) . __init__ () ... def predict_single ( self , input_instance ): return input_instance","title":"Saving Model Class"},{"location":"PyTorch/#predict_single","text":"The predict_single method will be called once for every query you run against the inference server. It must accept native input (e.g. text, image bytes, number array) and return a JSON serializable object that will be sent back to the user. Here are a few input/output examples:","title":"predict_single"},{"location":"PyTorch/#text-classification","text":"Liverpool beat Manchest United 4-2 on May 13th --> sports where can i find the best food in town? --> location In the face of overwhelming failure, Tom found success --> quotes Here is a more complex example that starts up a neural network trained to classify news articles. from torch import nn import torch.tensor from torchtext.datasets import AG_NEWS from torchtext.data.utils import get_tokenizer from collections import Counter from torchtext.vocab import Vocab tokenizer = get_tokenizer ( \"basic_english\" ) train_iter = AG_NEWS ( split = \"train\" ) counter = Counter () for ( label , line ) in train_iter : counter . update ( tokenizer ( line )) vocab = Vocab ( counter , min_freq = 1 ) text_pipeline = lambda x : [ vocab [ token ] for token in tokenizer ( x )] label_pipeline = lambda x : int ( x ) - 1 ag_news_label = { 1 : \"World\" , 2 : \"Sports\" , 3 : \"Business\" , 4 : \"Sci/Tec\" } class TextClassificationModel ( nn . Module ): def __init__ ( self , vocab_size = 95812 , embed_dim = 64 , num_class = 4 ): super ( TextClassificationModel , self ) . __init__ () self . embedding = nn . EmbeddingBag ( vocab_size , embed_dim , sparse = True ) self . fc = nn . Linear ( embed_dim , num_class ) self . init_weights () self . tokenizer = text_pipeline def init_weights ( self ): initrange = 0.5 self . embedding . weight . data . uniform_ ( - initrange , initrange ) self . fc . weight . data . uniform_ ( - initrange , initrange ) self . fc . bias . data . zero_ () def forward ( self , tokens , offset ): embedded = self . embedding ( tokens , offset ) return self . fc ( embedded ) def predict_single ( self , input : str ): tokenized = torch . tensor ( text_pipeline ( input )) output = self . forward ( tokenized , torch . tensor ([ 0 ])) prediction = output . argmax ( 1 ) . item () + 1 return ag_news_label [ prediction ]","title":"Text classification"},{"location":"tensorflow/","text":"TensorFlow TensorFlow models can be packaged to a directory which makes it fairly easy to export and run on EasyTensor. TensorFlow exposes a save_model function for all Keras models. Once your model is trained, you can use this function to upload your model to EasyTensor. import os import easytensor export_path = os . path . join ( os . getcwd (), \"my_model\" ) print ( \"export_path: {} \" . format ( export_path )) tf . keras . models . save_model ( model , export_path , overwrite = True , include_optimizer = True , save_format = None , signatures = None , options = None ) model_id , access_token = easytensor . upload_model ( \"My first model\" , export_path )","title":"TensorFlow"},{"location":"tensorflow/#tensorflow","text":"TensorFlow models can be packaged to a directory which makes it fairly easy to export and run on EasyTensor. TensorFlow exposes a save_model function for all Keras models. Once your model is trained, you can use this function to upload your model to EasyTensor. import os import easytensor export_path = os . path . join ( os . getcwd (), \"my_model\" ) print ( \"export_path: {} \" . format ( export_path )) tf . keras . models . save_model ( model , export_path , overwrite = True , include_optimizer = True , save_format = None , signatures = None , options = None ) model_id , access_token = easytensor . upload_model ( \"My first model\" , export_path )","title":"TensorFlow"}]}